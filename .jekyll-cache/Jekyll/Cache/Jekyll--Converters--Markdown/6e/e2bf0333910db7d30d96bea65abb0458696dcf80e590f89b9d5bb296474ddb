I"<h1 id="access-level-modifiers--외부에서-접근-할-수-있는-레벨을-정해-주는-것">access level modifiers : 외부에서 접근 할 수 있는 레벨을 정해 주는 것.</h1>
<p>public : 어느 클래스에서도 접근이 가능 할 수 있다.
protected : 
default : 
 private : 같은 클래스 안 에서만 사용할 수 있다. but public 을 사용하면 된다.(내부적인 메소드)</p>

<p>static - class method ( 클래스 소속이다.)
no static - instance method (인스턴스 소속이다.)</p>

<h1 id="object-oriented-programming--객제지향-프로그래밍">Object Oriented Programming : 객제지향 프로그래밍</h1>
<p>class는 변수와 메소드를 정리해서 묶어놓은 상자 (System, Math, FileWriter)
instance는 class를 새로 복제해서 이름을 붙인 상자 (f1, f2)</p>

<p><em>OOP의 특징</em></p>

<p><strong>1.추상화</strong><br />
목적과 관련이 없는 부분을 제거하여 필요한 부분만을 표현하기 위한 개념.
지도에는 위성지도, 등고선지도 등 여러가지 지도가 있다 but 목적이 다르다.</p>
<ul>
  <li>위성지도
그 지형의 정확한 실제 모습을 담기 위한 목적의 지도</li>
  <li>등고선 지도
지형의 높낮이를 표현하기 위한 목적의 지도</li>
</ul>

<p>이를 객체와 클래스 관점에서 보면 객체들은 실제 그 모습이지만, 클래스는 객체들이 어떤 특징들이 있어야 한다고 정의하는게  추상화된 개념이다.</p>

<p><em>결론 : 추상화는 객체들의 공통된 특징을 파악해 정의해 놓은 설계 기법</em></p>

<p><strong>2.캡슐화</strong><br />
클래스의 입장에서 캡슐화를 살펴보면<br />
자바에서 접근 제어자 (public, protected 등) 이 있다.<br />
그중 private으로 정의된 속성은 알약의 실제 내용물이라고 생각하면 된다.<br />
private 속성은 외부에 알려줄 필요가 없으므로,<br />
<em>정보은닉</em>을 할 수 있다.</p>

<p>캡슐화 !=  정보은닉<br />
둘이 동일한 개념이 아니라 캡슐화를 하면 정보은닉을 할 수 있다는 특징이 있다는 것이다.<br />
예를 들어, TV의 리모콘을 사용하는데 리모콘의 내부 회로(private으로 정의된 속성)를 알 필요가 있느냐,
사용자 입장에서는 리모콘의 조작 기능, 즉 public으로 정의된 속성만 알면 된다.</p>

<p><strong>3.상속</strong><br />
실제 세계에서 부모로부터 여러 가지를 상속을 받는데, OOP에서도 가능합니다.</p>

<p>OOP에서 이를 부모 클래스, 자식 클래스라고 표현합니다</p>

<p>예를 들어, 고양이 클래스, 강아지 클래스가 있다고 하겠습니다.<br />
그런데 고양이와 강아지는 생물학적 관점에서 포유류에 해당합니다.<br />
포유류는 여러 속성들이 정의되어 있는데 고양이와 강아지는 포유류의 이런 속성들을 갖고 있습니다.<br />
하지만 아주 많은 속성이 다르기 때문에 좀 더 디테일하게 고양이, 강아지로 종을 나뉘게 된 것이죠.</p>

<p>즉, 포유류라는 클래스는 고양이와 강아지 클래스에 속성들을 물려줍니다.<br />
이것을 상속이라고 하고, 포유류와 고양이, 포유류와 강아지 클래스는 상속관계에 있다고 합니다.</p>

<p>상속이 필요한 이유는 코드의 중복을 없애기 위함입니다.<br />
코드의 중복이 많아지면 개발 단계에서도 피곤하지만, 유지 보수에서도 많은 비용이 들게 됩니다. ( =&gt; 코드의 이원화 문제 )<br />
그래서 개발을 할 때 코드의 중복은 반드시 피해야 합니다.</p>

<p>OOP에서는 상속을 통해 코드의 중복 문제를 일부 해결할 수 있습니다.<br />
포유류 클래스에 여러 속성들을 정의해 놓고 포유류에 해당하는 종, 예를 들면 강아지 클래스가 필요할 경우 포유류 클래스와 상속 관계를 맺습니다.</p>

<p>상속관계를 맺으면 자식 객체를 생성할 때 부모 클래스의 속성들을 자동으로 물려받기 때문에 자식 클래스에서 또 정의할 필요가 없습니다.</p>

<p><strong>4.다형성</strong><br />
<em>다형성은 형태가 같은데 다른 기능을 하는 것을 의미합니다.</em></p>

<p>예를 들면, 고양이 클래스에는 “울음”이라는 속성이 정의되어 있다고 하겠습니다.<br />
사자는 고양이 과이기 때문에 사자 클래스는 고양이 클래스를 상속 받는다고 하면, 사자 클래스에도 “울음”이라는 속성이 자동으로 추가됩니다.<br />
앞에서 이것을 상속이라 했습니다.</p>

<p>그런데 고양이와 사자의 울음소리는 다르다는 것을 알고 있습니다.<br />
고양이는 “야옹”, 사자는 “크허헝” 인가요…? 어쨋든 사자는 무섭게 울어댑니다.<br />
같은 “울음” 속성임에도 실제 울음소리는 다르죠.<br />
이것이 다형성입니다.</p>

<p>부모 클래스로부터 상속을 받은 속성에 대해, 자식 클래스에서 물려받은 속성을 재정의 할 수 있습니다.<br />
이것을 오버라이딩이라고 합니다.<br />
즉, 사자 클래스는 부모클래스인 고양이 클래스의 “울음” 속성을 상속 받았지만, 사자는 고양이와 울음소리가 다르므로 “울음” 속성을 오버라이딩 해서 사자 울음소리에 맞게 재정의 할 수 있습니다.<br />
OOP에서는 이러한 다형성을 허용하는 것이죠.</p>

<p>그럼 다형성을 사용하면 좋은 점은 무엇일까요?<br />
같은 이름의 속성을 유지함으로서, 속성을 사용하기 위한 인터페이스를 유지하고, 메서드 이름을 낭비하지 않는다는 것입니다.</p>

<p>예를 들어, 고양이와 사자의 울음소리를 호출하기 위해서 각 개체에서 roar() 메서드를 호출하면 됩니다.<br />
roarCat() , roarLion() 으로 각각을 정의할 필요가 없다는 것이죠.<br />
API가 많아질수록 복잡성은 증가하기 때문에 다형성은 유용합니다.</p>

<h1 id="정리">정리</h1>
<ul>
  <li>OOP
    <ul>
      <li>객체들이 서로 유기적으로 동작하는 프로그래밍 이론</li>
      <li>코드의 재사용성과 중복제거가 가장 큰 목적</li>
    </ul>
  </li>
  <li>추상화
    <ul>
      <li>목적과 관련이 없는 부분을 제외해서 필요한 부분을 포착하는 기법</li>
      <li>객체의 공통된 속성들 중 필요한 부분을 포착해서 클래스로 정의하는 설계 기법</li>
    </ul>
  </li>
  <li>캡슐화
    <ul>
      <li>외부에 노출할 필요가 없는 정보들은 은닉 (정보은닉)</li>
    </ul>
  </li>
  <li>상속
    <ul>
      <li>상속 관계에 있는 두 클래스에 대해, 부모 클래스가 자손 클래스에게 속성을 물려주는 것</li>
      <li>코드의 재사용이 목적</li>
    </ul>
  </li>
  <li>다형성
    <ul>
      <li>같은 형태이지만 다른 기능을 하는 것</li>
      <li>오버라이딩은 이와 관련된 기능임</li>
    </ul>
  </li>
</ul>
:ET